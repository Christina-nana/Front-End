<html><head><meta charset="utf-8"><title>30 React基本功（一）——图解新旧生命周期-慕课专栏</title>
			<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
			<meta name="renderer" content="webkit">
			<meta property="qc:admins" content="77103107776157736375">
			<meta property="wb:webmaster" content="c4f857219bfae3cb">
			<meta http-equiv="Access-Control-Allow-Origin" content="*">
			<meta http-equiv="Cache-Control" content="no-transform ">
			<meta http-equiv="Cache-Control" content="no-siteapp">
			<link rel="apple-touch-icon" sizes="76x76" href="https://www.imooc.com/static/img/common/touch-icon-ipad.png">
			<link rel="apple-touch-icon" sizes="120x120" href="https://www.imooc.com/static/img/common/touch-icon-iphone-retina.png">
			<link rel="apple-touch-icon" sizes="152x152" href="https://www.imooc.com/static/img/common/touch-icon-ipad-retina.png">
			<link href="https://moco.imooc.com/captcha/style/captcha.min.css" rel="stylesheet">
			<link rel="stylesheet" href="https://www.imooc.com/static/moco/v1.0/dist/css/moco.min.css?t=201907021539" type="text/css">
			<link rel="stylesheet" href="https://www.imooc.com/static/lib/swiper/swiper-3.4.2.min.css?t=201907021539">
			<link rel="stylesheet" href="https://static.mukewang.com/static/css/??base.css,common/common-less.css?t=2.5,column/zhuanlanChapter-less.css?t=2.5,course/inc/course_tipoff-less.css?t=2.5?v=201907051055" type="text/css">
			<link charset="utf-8" rel="stylesheet" href="https://www.imooc.com/static/lib/ueditor/themes/imooc/css/ueditor.css?v=201907021539"><link rel="stylesheet" href="https://www.imooc.com/static/lib/baiduShare/api/css/share_style0_16.css?v=6aba13f0.css"></head>
			<body><div id="main">


<div class="main-con hide-menu">
    <!-- 左侧菜单 & 索引 -->
    
    <div class="right-content" style="padding-left: 0px;">
        <div class="container clearfix" id="top" style="width: 1134px; display: block;">
            
            
            <div class="center_con js-center_con l" style="width: 1134px;">
                <div class="article-con">
                                            <!-- 买过的阅读 -->
                        

                    
                    <div class="art-title" style="margin-top: 0px;">
                        30 React基本功（一）——图解新旧生命周期
                    </div>
                    <div class="art-info clearfix">
                        
                        <span class="l">
                            更新时间：2020-05-26 13:57:48
                        </span>
                    </div>
                    <div class="art-top">
                                                <img src="https://img3.sycdn.imooc.com/5ec653b5000112bf06400427.jpg" alt="">
                                                                        <div class="famous-word-box">
                            <img src="https://www.imooc.com/static/img/column/bg-l.png" alt="" class="bg1 bg">
                            <img src="https://www.imooc.com/static/img/column/bg-r.png" alt="" class="bg2 bg">
                            <div class="famous-word">宝剑锋从磨砺出，梅花香自苦寒来。——佚名<p></p></div>
                        </div>
                                            </div>
                    <div class="art-content js-lookimg">
                        <div id="article_content">
                            <div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">本节开始，我们进入前端框架的世界。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">相信每一个有面试打算的工程师，对React、Vue这样的当红轮子都不会是一无所知的状态。对于大家而言，单纯说轮子的使用，一定不是啥难事儿。在框架这个知识板块，我们强调的是“原理”和“表达”。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">原理不必多讲，肯定是我们备考的重点——但凡稍微有点面试经验的同学，都会清楚框架源码、底层机制这些东西在面试官眼里的重要性。我这里想要强调的是“表达”——很多同学认为，有了日常工作中的频繁使用，自己对框架基础已经不能更熟悉，便忽视了对基础知识的准备。结果面试现场，受试者面对框架基础类型的考题，总是噤若寒蝉——这时候才发现，原来会写代码，和能说囫囵是两回事；原来就算工作中写了那么多React代码，可脑子里也只记住了最最高频的那些操作——原来，会用和理解是两回事；原来，你的框架基础并没有想象中扎实。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">​</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">React开篇，我们不讲虚拟DOM，不讲Fiber架构，我先带大家把React常考的基础知识整个给串一遍：</p>
</div><div class="cl-preview-section"><h2 id="react-新旧生命周期" style="font-size: 30px;">React 新旧生命周期</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">大家知道，随着 React16 的发布和推广，新的 React 生命周期越来越为广大开发者所接受。不过在一些团队，可能因为各种各样的原因，他们并没有进行 React 的版本迁移，因此面试官仍然对老生命周期更感兴趣。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">学新还是学旧，这个咱们不纠结——小孩子才做选择，面试的人当然是全都要啊！</p>
</div><div class="cl-preview-section"><h2 id="旧生命周期" style="font-size: 30px;">旧生命周期</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">先从旧的生命周期说起，旧的 React 包括以下几个主要的生命周期函数：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;"><strong>componentWillMount</strong></li>
<li style="font-size: 20px; line-height: 38px;"><strong>componentDidMount</strong></li>
<li style="font-size: 20px; line-height: 38px;"><strong>componentWillReceiveProps</strong></li>
<li style="font-size: 20px; line-height: 38px;"><strong>shouldComponentUpdate</strong></li>
<li style="font-size: 20px; line-height: 38px;"><strong>componentWillUpdate</strong></li>
<li style="font-size: 20px; line-height: 38px;"><strong>componentDidUpdate</strong></li>
<li style="font-size: 20px; line-height: 38px;"><strong>componentWillUnmount</strong></li>
</ul>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;">注意： React的生命周期流程从广义上分为三个阶段：<strong>挂载、更新、卸载</strong>。</p>
</blockquote>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">以上函数各自有着自己的执行时机。关于执行时机，我们需要考虑四种情况：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">React 初始化应用时 （挂载阶段）</li>
<li style="font-size: 20px; line-height: 38px;">props 发生数据更新 （更新阶段）</li>
<li style="font-size: 20px; line-height: 38px;">state 发生数据更新  （更新阶段）</li>
<li style="font-size: 20px; line-height: 38px;">卸载应用时 (卸载阶段，比较简单，仅涉及 componentWillUnmount）</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">​</p>
</div><div class="cl-preview-section"><h4 id="卸载" style="font-size: 26px;">卸载</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们先来说说最简单的卸载阶段：</p>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;"><code>componentWillUnmount()</code> 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 <code>componentDidMount()</code> 中创建的订阅等。</p>
</blockquote>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">简单说，这个生命周期钩子，就是一个“扫地僧”啊！</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">相比卸载阶段而言，前三种情形会比较有嚼头，也是面试的重点。它们分别对应了不同的生命周期流程（下面画图说明）：</p>
</div><div class="cl-preview-section"><h4 id="初始化" style="font-size: 26px;">初始化</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">首先，是初始化应用，也即第一次 render 页面时：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://img1.sycdn.imooc.com/5ec65497000122cf10980720.png" data-original="//img1.sycdn.imooc.com/5ec65497000122cf10980720.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">大家看到，这里除了我们提到过的生命周期函数以外，还涉及一些其它的 React 函数。我们一一来看：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;"><strong>getDefaultProps</strong>：这个函数会在组件创建之前被调用一次（有且仅有一次），它被用来初始化组件的 Props；</li>
<li style="font-size: 20px; line-height: 38px;"><strong>getInitialState</strong>：用于初始化组件的 state 值；</li>
<li style="font-size: 20px; line-height: 38px;"><strong>componentWillMount</strong>：在组件创建后、render 之前，会走到 componentWillMount 阶段。这个阶段我个人一直没用过、非常鸡肋。后来React 官方已经不推荐大家在 componentWillMount 里做任何事情、到现在 <strong>React16 直接废弃了这个生命周期</strong>，足见其鸡肋程度了；</li>
<li style="font-size: 20px; line-height: 38px;"><strong>render</strong>：这是所有生命周期中唯一一个你必须要实现的方法。一般来说需要返回一个 jsx 元素，这时 React 会根据 props 和 state 来把组件渲染到界面上；不过有时，你可能不想渲染任何东西，这种情况下让它返回 null 或者 false 即可；</li>
<li style="font-size: 20px; line-height: 38px;"><strong>componentDidMount</strong>：会在组件挂载后（插入 DOM 树中后）立即调用，标志着组件挂载完成。一些操作如果依赖获取到 DOM 节点信息，我们就会放在这个阶段来做。此外，这还是 React 官方推荐的发起 ajax 请求的时机。该方法和 componentWillMount 一样，有且仅有一次调用。</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">初始化完成后，我们需要考虑数据更新的两种情况（下面两张图分别对应 state 和 props的更新）：</p>
</div><div class="cl-preview-section"><h4 id="state-更新流程：" style="font-size: 26px;">state 更新流程：</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://img1.sycdn.imooc.com/5ec6549f00016d9c10400650.png" data-original="//img1.sycdn.imooc.com/5ec6549f00016d9c10400650.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们一起来看看这个过程当中涉及的函数：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">shouldComponentUpdate:  当组件的 state 或 props 发生改变时，都会首先触发这个生命周期函数。它会接收两个参数：nextProps, nextState——它们分别代表传入的新 props 和新的 state 值。拿到这两个值之后，我们就可以通过一些对比逻辑来决定是否有 re-render（重渲染）的必要了。如果该函数的返回值为 false，则生命周期终止，反之继续；</li>
</ol>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;">注意：此方法仅作为<strong>性能优化的方式</strong>而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该<strong>考虑使用内置的 PureComponent 组件</strong>，而不是手动编写 <code>shouldComponentUpdate()</code></p>
</blockquote>
</div><div class="cl-preview-section"><ol start="2">
<li style="font-size: 20px; line-height: 38px;">componentWillUpdate：当组件的 state 或 props 发生改变时，会在渲染之前调用 componentWillUpdate。componentWillUpdate <strong>是 React16 废弃的三个生命周期之一</strong>。过去，我们可能希望能在这个阶段去收集一些必要的信息（比如更新前的 DOM 信息等等），现在我们完全可以在 React16 的 getSnapshotBeforeUpdate 中去做这些事；</li>
<li style="font-size: 20px; line-height: 38px;">componentDidUpdate：componentDidUpdate() 会在UI更新后会被立即调用。它接收 prevProps（上一次的 props 值）作为入参，也就是说在此处我们仍然可以进行 props 值对比（再次说明 componentWillUpdate 确实鸡肋哈）。</li>
</ol>
</div><div class="cl-preview-section"><h4 id="props-更新流程：" style="font-size: 26px;">props 更新流程：</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://img1.sycdn.imooc.com/5ec654a80001b81910420776.png" data-original="//img1.sycdn.imooc.com/5ec654a80001b81910420776.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">相对于 state 更新，props 更新后唯一的区别是增加了对 componentWillReceiveProps 的调用。关于 componentWillReceiveProps，你需要知道这些事情：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">componentWillReceiveProps：它在Component接受到新的 props 时被触发。componentWillReceiveProps 会接收一个名为 nextProps 的参数（对应新的 props 值）。<strong>该生命周期是 React16 废弃掉的三个生命周期之一</strong>。在它被废弃前，一些同学可能习惯于用它来比较 this.props 和 nextProps 来重新setState。在 React16 中，我们用一个类似的新生命周期  getDerivedStateFromProps 来代替它。</li>
</ul>
</div><div class="cl-preview-section"><h2 id="新生命周期" style="font-size: 30px;">新生命周期</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">关于 React16 开始应用的新生命周期，React 官方（<a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a>）提供的这张图表很能说明问题：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img class="" src="https://img1.sycdn.imooc.com/5ec654af0001307319781002.png" data-original="//img1.sycdn.imooc.com/5ec654af0001307319781002.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">图中我们可以看出，React16 自上而下地对生命周期做了另一种维度的解读：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;"><strong>Render 阶段</strong>：用于计算一些必要的状态信息。这个阶段可能会被 React 暂停，这一点和 React16 引入的 Fiber 架构（我们后面会重点讲解）是有关的；</li>
<li style="font-size: 20px; line-height: 38px;"><strong>Pre-commit阶段</strong>：所谓“commit”，这里指的是“更新真正的 DOM 节点”这个动作。所谓 Pre-commit，就是说我在这个阶段其实还并没有去更新真实的 DOM，不过 DOM 信息已经是可以读取的了；</li>
<li style="font-size: 20px; line-height: 38px;"><strong>Commit 阶段</strong>：在这一步，React 会完成真实 DOM 的更新工作。Commit 阶段，我们可以拿到真实 DOM（包括 refs）。</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">与此同时，新的生命周期在流程方面，仍然遵循“挂载”、“更新”、“卸载”这三个广义的划分方式。它们分别对应到：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">
<p style="font-size: 20px; line-height: 38px;">挂载过程：</p>
<ul>
<li style="font-size: 20px; line-height: 38px;"><strong>constructor</strong></li>
<li style="font-size: 20px; line-height: 38px;"><strong>getDerivedStateFromProps</strong></li>
<li style="font-size: 20px; line-height: 38px;"><strong>render</strong></li>
<li style="font-size: 20px; line-height: 38px;"><strong>componentDidMount</strong></li>
</ul>
</li>
<li style="font-size: 20px; line-height: 38px;">
<p style="font-size: 20px; line-height: 38px;">更新过程：</p>
<ul>
<li style="font-size: 20px; line-height: 38px;"><strong>getDerivedStateFromProps</strong></li>
<li style="font-size: 20px; line-height: 38px;"><strong>shouldComponentUpdate</strong></li>
<li style="font-size: 20px; line-height: 38px;"><strong>render</strong></li>
<li style="font-size: 20px; line-height: 38px;"><strong>getSnapshotBeforeUpdate</strong></li>
<li style="font-size: 20px; line-height: 38px;"><strong>componentDidUpdate</strong></li>
</ul>
</li>
<li style="font-size: 20px; line-height: 38px;">
<p style="font-size: 20px; line-height: 38px;">卸载过程：</p>
<ul>
<li style="font-size: 20px; line-height: 38px;"><strong>componentWillUnmount</strong></li>
</ul>
</li>
</ul>
</div><div class="cl-preview-section"><br>
以上这些生命周期方法，红字标注的是咱们到现在为止还没介绍过的，也是 React16 新增的两个方法、需要大家重点关注：
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;"><strong>getDerivedStateFromProps</strong></li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在 render 方法之前调用，它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。它接收 props 和 state 两个入参，从调用时机和实际场景上，它都微妙地对标了<strong>componentWillReceiveProps</strong> 这个已经被废弃的旧方法。<br>
注意！React官方并不推荐开发者使用该方法：</p>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;">此方法适用于<a href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state">罕见的用例</a>，即 state 的值在任何时候都取决于 props。否则，派生状态会导致代码冗余，并使组件难以维护。</p>
</blockquote>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">更何况，大部分的派生状态咱们都有更好的替代方案可以解决（当然这不是咱们复习的重点，感兴趣的同学戳<a href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization">更好的派生状态方式</a>了解派生状态新姿势~）。</p>
</div><div class="cl-preview-section"><ol start="2">
<li style="font-size: 20px; line-height: 38px;"><strong>getSnapshotBeforeUpdate</strong></li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这个方法会接受 prevProps、prevState 两个入参</p>
</div><div class="cl-preview-section"><pre><code>   getSnapshotBeforeUpdate(prevProps, prevState)
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><strong>这个生命周期函数必须有返回值</strong>——它的返回值会作为第三个参数传递给 <code>componentDidUpdate</code>。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">注意，因为走到这一步时，React 已经更新上了所有状态，所以新状态可以通过 this.props、this.state 获取。所以结合两个入参，我们可以拿到所有的新旧状态。不过即便这个方法能提供的信息如此丰富，它也并不常用：</p>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;">此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。</p>
</blockquote>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">​</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">因为用得少，所以面试官对于 getSnapshotBeforeUpdate 的询问普遍也是蜻蜓点水。不过这里以防万一，我还是给大家提一嘴：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">结合个人经验来看，因为 getSnapshotBeforeUpdate 触发时，真实的 DOM 节点还没有更新；此外，它又可以和 componentDidMount（DOM 节点更新后触发的钩子） 通信。大家知道，一些场景下，我们是需要对更新前后的 DOM 节点信息作一些对比或是处理的。比如说我想知道更新前后，某一个 div 的位置移动了多少，以此来决定是否来把它矫正回原位、或者是直接帮它移动一个更合适的距离呢？这种情况下，用 getSnapshotBeforeUpdate 就再合适不过啦~</p>
</div>}
                        </div>
                    </div>
                                            <!-- 买过的阅读 -->
                        <div class="art-next-prev clearfix">
                                                                                                <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/70/article/1972">
                                                                    <div class="prev l clearfix">
                                        <div class="icon l">
                                            <i class="imv2-arrow3_l"></i>
                                        </div>
                                        <p>
                                            29 Node事件循环命题思路剖析
                                        </p>
                                    </div>
                                </a>
                                                                                                                            <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/70/article/2009">
                                                                    <div class="next r clearfix">
                                        <p>
                                            31 React基本功（二）——深入组件通信机制
                                        </p>
                                        <div class="icon r">
                                            <i class="imv2-arrow3_r"></i>
                                        </div>

                                    </div>
                                </a>
                                                    </div>
                                    </div>
                <div class="comments-con js-comments-con" id="coments_con">
                </div>

                
            </div>
            
            
            

        </div>
    </div>
</div>

<div class="modal modal-jiaQun-new hide" id="modal-jiaQun">
    <div class="inner" style="">
        <div class="modal-close js-close-jiaQun">
            <i class="imv2-close"></i>
        </div>
        <div class="content">
            <img src="https://img4.sycdn.imooc.com/5f7fdf360001c7e905660544.jpg">
            <div class="right-info">
                <div class="title">
                    扫码加入慕课前端核心用户群
                </div>
                <div class="desc">
                                            <p class="mb6">验证信息：<span id="joincode">2010271938441361</span><span class="copy js-copy-joincode">复制</span></p>
                                        <p class="mb6">QQ讨论群号：906667001</p>
                                            <p>QQ群URL：<a href="https://jq.qq.com/?_wv=1027&amp;k=AKUF96AI" target="_blank">点击访问</a></p>
                                    </div>
            </div>
            <p class="tip">若遇到搜索不到QQ群或加群失败，请联系客服邮箱:kf@imooc.com</p>
        </div>
    </div>
</div>
 
<!-- 专栏介绍页专栏评价 -->

<!-- 专栏介绍页底部三条评价 -->

<!-- 专栏阅读页弹层目录和介绍页页面目录 -->

<!-- 专栏阅读页发布回复 -->

<!-- 专栏阅读页发布评论 -->

<!-- 专栏阅读页底部评论 -->

<!-- 专栏阅读 单个 评论 -->

<!-- 新增回复和展开三条以外回复 -->

<!-- 立即订阅的弹窗 -->












</div></body></html>